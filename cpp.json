{
    "CP Template": {
        "prefix": "cp",
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "#define int long long",
            "",
            "#ifdef local",
            "#include \"debug.h\"",
            "#else",
            "#define db(...)",
            "#endif",
            "",
            "void solve() {",
            "    $1",
            "}",
            "",
            "int32_t main() {",
            "\tcin.tie(0)->sync_with_stdio(0);",
            "\tint tc = 1;",
            "\tcin >> tc;",
            "\twhile (tc--) solve();",
            "}",
            "",
            "/*",
            " *",
            "*/"
        ],
        "description": "Competitive Programming Template"
    },
    "Prac Template": {
        "prefix": "cpp",
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "using ll = long long;",
            "",
            "void solve() {",
            "    $1",
            "}",
            "",
            "int32_t main() {",
            "\tcin.tie(0)->sync_with_stdio(0);",
            "\tint tc = 1;",
            "\tcin >> tc;",
            "\twhile (tc--) solve();",
            "}",
            "",
            "/*",
            " *",
            "*/"
        ],
        "description": "Competitive Programming Template"
    },
    "Read Vector": {
        "prefix": "readvec",
        "body": [
            "vector<${1:int}> ${2:a}(${3:n});",
            "for (int i = 0; i < ${3:n}; i++) {",
            "\tcin >> ${2:a}[i];",
            "}"
        ],
        "description": "Read a vector of integers"
    },
    "DFS": {
        "prefix": "dfs",
        "body": [
            "auto dfs = [&](this auto&& dfs, int ${1:u}, int ${2:p}) -> ${3:void} {",
            "\tfor (auto ${4:v} : ${5:g}[${1:u}]) {",
            "\t\tif (${4:v} == ${2:p}) continue;",
            "\t\t$0",
            "\t}",
            "};"
        ],
        "description": "DFS lambda function for graph traversal"
    },
    "Read Graph": {
        "prefix": "readg",
        "body": [
            "vector<vector<int>> ${1:g}(${2:n});",
            "for (int i = 0; i < ${3:m}; i++) {",
            "\tint u, v;",
            "\tcin >> u >> v;",
            "\tu--, v--;",
            "\t${1:g}[u].push_back(v);",
            "\t${1:g}[v].push_back(u);",
            "}"
        ],
        "description": "Read an undirected graph"
    },
    
    "USACO Template": {
        "prefix": "cses",
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "#define int long long",
            "",
            "int32_t main() {",
            "\tcin.tie(0)->sync_with_stdio(0);",
            "\t$1",
            "",
            "}",
            "",
            "/*",
            " *",
            "*/"
        ],
        "description": "usaco temp"
    },
    "Power Modulo": {
        "prefix": "mopo",
        "body": [
            "int mopo(int ${1:b}, int ${2:e}) {",
            "\tif (${2:e} == 0) return 1;",
            "\tint r = mopo(${1:b}, ${2:e} >> 1);",
            "\tr = r * r % ${3:mod};",
            "\treturn r * ((${2:e} & 1) ? ${1:b} : 1) % ${3:mod};",
            "}"
        ],
        "description": "Power modulo function"
    },
    "Modular Inverse": {
        "prefix": "moiv",
        "body": [
            "int moiv(int ${1:a}) { return mopo(${1:a}, ${2:mod} - 2); }"
        ],
        "description": "Modular inverse function"
    },
    "Debug Header": {
        "prefix": "debug",
        "body": [
            "#ifdef local",
            "#include \"debug.h\"",
            "#else",
            "#define db(...)",
            "#endif"
        ],
        "description": "Include debug header for local development"
    },
    "Infinity Constant": {
        "prefix": "inf",
        "body": "constexpr int inf = 2E9;",
        "description": "Infinity constant"
    },
    "Newline": {
        "prefix": "endll",
        "body": "\"\\n\"",
        "description": "Newline character"
    },
    "Disjoint Set Union": {
        "prefix": "dsu",
        "body": [
            "",
            "struct DSU {",
            "\tvector<int> p;",
            "\tDSU(int n) : p(n, -1) {}",
            "",
            "\tint get(int x) { return p[x] < 0 ? x : p[x] = get(p[x]); }",
            "",
            "\tbool merge(int x, int y) {",
            "\t\tx = get(x), y = get(y);",
            "\t\tif (x != y) {",
            "\t\t\tif (-p[x] < -p[y]) swap(x, y);",
            "\t\t\tp[x] += p[y], p[y] = x;",
            "\t\t\treturn true;",
            "\t\t}",
            "\t\treturn false;",
            "\t}",
            "",
            "\tint size(int x) { return -p[get(x)]; }",
            "",
            "\tbool same(int x, int y) { return get(x) == get(y); }",
            "};",
            ""
        ],
        "description": "Disjoint Set Union (DSU) structure"
    },
    "Dijkstra": {
        "prefix": "dijkstra",
        "body": [
            "",
            "vector<${1:int}> dijkstra(int ${2:src}, const vector<vector<array<${1:int}, 2>>> &${3:g}) {",
            "\tint n = ${3:g}.size();",
            "\tvector<${1:int}> d(n, ${4:INT_MAX});",
            "",
            "\tpriority_queue<array<${1:int}, 2>, vector<array<${1:int}, 2>>, greater<>> pq;",
            "\tpq.push({0, ${2:src}});",
            "\td[${2:src}] = 0;",
            "",
            "\twhile (!pq.empty()) {",
            "\t\tauto [dis, u] = pq.top();",
            "\t\tpq.pop();",
            "\t\tif (d[u] != dis) continue;",
            "",
            "\t\tfor (auto [v, w] : ${3:g}[u]) {",
            "\t\t\tif (d[v] > dis + w) {",
            "\t\t\t\td[v] = dis + w;",
            "\t\t\t\tpq.push({d[v], v});",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\treturn d;",
            "}",
            ""
        ],
        "description": "Dijkstra's algorithm implementation"
    },
    "Modular Integer": {
        "prefix": "modint",
        "body": [
            "",
            "template <int P> struct modint {",
            "\tint v;",
            "",
            "\tmodint(long long val = 0) : v(val % P) {",
            "\t\tif (v < 0) v += P;",
            "\t}",
            "",
            "\tstatic constexpr int mod() { return P; }",
            "",
            "\tmodint &operator+=(const modint &rhs) {",
            "\t\tv += rhs.v;",
            "\t\tif (v >= P) v -= P;",
            "\t\treturn *this;",
            "\t}",
            "\tmodint &operator-=(const modint &rhs) {",
            "\t\tv -= rhs.v;",
            "\t\tif (v < 0) v += P;",
            "\t\treturn *this;",
            "\t}",
            "\tmodint &operator*=(const modint &rhs) {",
            "\t\tv = static_cast<long long>(v) * rhs.v % P;",
            "\t\treturn *this;",
            "\t}",
            "",
            "\tmodint pow(long long n) const {",
            "\t\tmodint res = 1, a = *this;",
            "\t\twhile (n > 0) {",
            "\t\t\tif (n & 1) res *= a;",
            "\t\t\ta *= a;",
            "\t\t\tn >>= 1;",
            "\t\t}",
            "\t\treturn res;",
            "\t}",
            "\tmodint inv() const { return pow(P - 2); }",
            "\tmodint &operator/=(const modint &rhs) { return *this *= rhs.inv(); }",
            "",
            "\tfriend modint operator+(modint lhs, const modint &rhs) { return lhs += rhs; }",
            "\tfriend modint operator-(modint lhs, const modint &rhs) { return lhs -= rhs; }",
            "\tfriend modint operator*(modint lhs, const modint &rhs) { return lhs *= rhs; }",
            "\tfriend modint operator/(modint lhs, const modint &rhs) { return lhs /= rhs; }",
            "",
            "\tfriend ostream &operator<<(ostream &os, const modint &m) { return os << m.v; }",
            "\tfriend istream &operator>>(istream &is, modint &m) {",
            "\t\tlong long val;",
            "\t\tis >> val;",
            "\t\tm = modint(val);",
            "\t\treturn is;",
            "\t}",
            "};",
            "",
            "constexpr int MOD = ${1:998244353};",
            "using Z = modint<MOD>;",
            ""
        ],
        "description": "Modular arithmetic (modint) struct"
    },
    "Combinatorics": {
        "prefix": "math",
        "body": [
            "",
            "template <typename T> struct math {",
            "\tvector<T> fact, invFact;",
            "\tmath(int n) : fact(n + 1), invFact(n + 1) {",
            "\t\tfact[0] = 1;",
            "\t\tfor (int i = 1; i <= n; ++i) { fact[i] = fact[i - 1] * i; }",
            "\t\tinvFact[n] = fact[n].inv();",
            "\t\tfor (int i = n; i > 0; --i) { invFact[i - 1] = invFact[i] * i; }",
            "\t}",
            "",
            "\tT nCr(int n, int r) const {",
            "\t\tif (r < 0 || r > n) return 0;",
            "\t\treturn fact[n] * invFact[r] * invFact[n - r];",
            "\t}",
            "",
            "\tT nPr(int n, int r) const {",
            "\t\tif (r < 0 || r > n) return 0;",
            "\t\treturn fact[n] * invFact[n - r];",
            "\t}",
            "};",
            ""
        ],
        "description": "Combinatorics helper (nCr, nPr)"
    },
    "USACO File IO": {
        "prefix": "setio",
        "body": [
            "void setIO(string ${1:s}) {",
            "\tfreopen((${1:s} + \".in\").c_str(), \"r\", stdin);",
            "\tfreopen((${1:s} + \".out\").c_str(), \"w\", stdout);",
            "}"
        ],
        "description": "USACO file input/output setup"
    },
    "Trie": {
        "prefix": "trie",
        "body": [
            "",
            "template <int N, char id> struct Trie {",
            "\tstruct node {",
            "\t\tarray<int, N> go;",
            "\t\tint cnt = 0, end = 0;",
            "\t};",
            "\tvector<node> d;",
            "",
            "\tint add_node() {",
            "\t\td.emplace_back();",
            "\t\treturn d.size() - 1;",
            "\t}",
            "\tTrie() { add_node(); }",
            "",
            "\tvoid insert(const string &s) {",
            "\t\tint rt = 0;",
            "\t\tfor (const auto &c : s) {",
            "\t\t\tif (!d[rt].go[c - id]) { d[rt].go[c - id] = add_node(); }",
            "\t\t\trt = d[rt].go[c - id];",
            "\t\t\td[rt].cnt++;",
            "\t\t}",
            "\t\td[rt].end++;",
            "\t}",
            "",
            "\tvoid erase(const string &s) {",
            "\t\tint rt = 0;",
            "\t\tfor (const auto &c : s) {",
            "\t\t\trt = d[rt].go[c - id];",
            "\t\t\td[rt].cnt--;",
            "\t\t}",
            "\t\td[rt].end--;",
            "\t}",
            "};",
            ""
        ],
        "description": "Trie data structure"
    },
    "BIT": {
        "prefix": "bit",
        "body": [
            "",
            "template <class T> struct BIT {",
            "\tint n;",
            "\tvector<T> d;",
            "\tBIT(int _n) : n(_n), d(_n) {}",
            "",
            "\tT sum(int r) {",
            "\t\tT s = 0;",
            "\t\tfor (++r; r > 0; r -= r & -r) { s += d[r - 1]; }",
            "\t\treturn s;",
            "\t}",
            "\tT sum(int l, int r) { return sum(r) - sum(l - 1); }",
            "",
            "\tvoid add(int i, T delta) {",
            "\t\tfor (++i; i <= n; i += i & -i) { d[i - 1] += delta; }",
            "\t}",
            "",
            "\tint get(T k) {",
            "\t\tk++;",
            "\t\tint cur{};",
            "\t\tif (k > sum(n - 1)) { return -1; }",
            "",
            "\t\tfor (int po = __bit_width(unsigned(n)) - 1; po >= 0; po--) {",
            "\t\t\tint nu = cur + (1 << po);",
            "\t\t\tif (nu <= n && d[nu - 1] < k) {",
            "\t\t\t\tk -= d[nu - 1];",
            "\t\t\t\tcur = nu;",
            "\t\t\t}",
            "\t\t}",
            "\t\treturn cur;",
            "\t}",
            "};",
            ""
        ],
        "description": "Binary Indexed Tree (Fenwick Tree)"
    },
    "BIT 2D": {
        "prefix": "bit2d",
        "body": [
            "",
            "template <class T> struct BIT2D {",
            "\tint n, m;",
            "\tvector<vector<T>> d;",
            "\tBIT2D(int _n, int _m) : n(_n), m(_m), d(_n, vector<T>(_m)) {}",
            "",
            "\tvoid add(int r, int c, T delta) {",
            "\t\tfor (int i = r + 1; i <= n; i += i & -i) {",
            "\t\t\tfor (int j = c + 1; j <= m; j += j & -j) { d[i - 1][j - 1] += delta; }",
            "\t\t}",
            "\t}",
            "",
            "\tT sum(int r, int c) {",
            "\t\tT s = 0;",
            "\t\tfor (int i = r + 1; i > 0; i -= i & -i) {",
            "\t\t\tfor (int j = c + 1; j > 0; j -= j & -j) { s += d[i - 1][j - 1]; }",
            "\t\t}",
            "\t\treturn s;",
            "\t}",
            "",
            "\tT sum(int r1, int c1, int r2, int c2) { return sum(r2, c2) - sum(r1 - 1, c2) - sum(r2, c1 - 1) + sum(r1 - 1, c1 - 1); }",
            "};",
            ""
        ],
        "description": "2D Binary Indexed Tree (Fenwick Tree)"
    },
    "Sparse Table": {
        "prefix": "sparsetable",
        "body": [
            "",
            "template <class S, S (*op)(S, S), S e> struct sparse_table {",
            "\tint n, k;",
            "\tvector<vector<S>> st;",
            "",
            "\tsparse_table(const vector<S> &a) : n(a.size()), k(__bit_width(n)) {",
            "\t\tst.assign(k, vector<S>(n));",
            "\t\tst[0] = a;",
            "\t\tfor (int i = 1; i < k; i++) {",
            "\t\t\tfor (int j = 0; j + (1 << i) <= n; j++) { st[i][j] = op(st[i - 1][j], st[i - 1][j + (1 << (i - 1))]); }",
            "\t\t}",
            "\t}",
            "",
            "\tS query(int l, int r) {",
            "\t\tif (l >= r) return e;",
            "\t\tint i = __bit_width(r - l) - 1;",
            "\t\treturn op(st[i][l], st[i][r - (1 << i)]);",
            "\t}",
            "};",
            ""
        ],
        "description": "Sparse Table data structure"
    }
}
